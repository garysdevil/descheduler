# 开发
## 二次开发 
### 测试运行
CGO_ENABLED=0 go run  sigs.k8s.io/descheduler/cmd/descheduler --policy-config-file examples/develop.yaml --kubeconfig /tmp/admin.conf
CGO_ENABLED=0 go run  sigs.k8s.io/descheduler/cmd/descheduler --policy-config-file examples/develop.yaml --kubeconfig /tmp/admin.conf -v 3 --dry-run
### 添加新的依赖包
1. 修改go.mod
2. go mod vendor
### 添加新的struct
1. 在以下两个文件内都添加相同的struct
./pkg/api/types.go
./pkg/api/v1alpha1/types.go
2. 执行 make gen
    1. 生成的内部和外部类型之间转换的函数代码会被放置在${GOPATH}/src/sigs.k8s.io/descheduler/pkg目录下
    2. 注意对比生成新的代码与旧的差异
    3. pkg/api/v1alpha1/zz_generated.conversion.go
    ```go
    // Convert_componentconfig_DeschedulerConfiguration_To_v1alpha1_DeschedulerConfiguration is an autogenerated conversion function.
    func Convert_componentconfig_DeschedulerConfiguration_To_v1alpha1_DeschedulerConfiguration(in *componentconfig.DeschedulerConfiguration, out *DeschedulerConfiguration, s conversion.Scope) error {
        return autoConvert_componentconfig_DeschedulerConfiguration_To_v1alpha1_DeschedulerConfiguration(in, out, s)
    }
    ```
    4. 自动生成的文件
```
./pkg/api/v1alpha1/zz_generated.conversion.go // 不必要的更改
./pkg/api/v1alpha1/zz_generated.deepcopy.go // 必要的更改
./pkg/api/v1alpha1/zz_generated.defaults.go  // 必要的更改
./pkg/api/zz_generated.deepcopy.go  // 必要的更改
./pkg/apis/componentconfig/v1alpha1/zz_generated.conversion.go
./pkg/apis/componentconfig/v1alpha1/zz_generated.deepcopy.go
./pkg/apis/componentconfig/v1alpha1/zz_generated.defaults.go // 不必要的更改
./pkg/apis/componentconfig/zz_generated.deepcopy.go
```
## 参考文件
0. origin
https://github.com/kubernetes-sigs/descheduler
https://blog.csdn.net/xiashanrenlaozhang/article/details/92413091
1. KEP
https://docs.google.com/document/d/1ffBpzhqELmhqJxdGMzYzIOoigxn3J0zlP1_nie34f9s/edit#heading=h.defm38wxvjp1
https://github.com/kubernetes-sigs/scheduler-plugins/tree/master/kep/61-Trimaran-real-load-aware-scheduling
2. metrics 
https://stackoverflow.com/questions/52029656/how-to-retrieve-kubernetes-metrics-via-client-go-and-golang
https://github.com/kubernetes/metrics
3. kubernetes
https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.20/#watch-node-v1-core  
https://godoc.org/k8s.io/apimachinery/pkg/api/resource#pkg-index

# 使用
## 生产环境使用
```bash
cd kubernetes
# 创建rbac 和 配置文件configmap
kubectl create -f base/rbac.yaml
kubectl create -f base/configmap-new.yaml
# 创建 cronjob
kubectl create -f cronjob/cronjob.yaml
```

## 需求
1. 操作node间的间隔
2. node内终止pod的间隔
3. node内终止pod的个数
4. 禁止终止某些pod

- 需求
    1. 某些Pod启动缓慢
    2. 始终保持至少有一个副本是可用状态
    3. 某些job的任务及其重要，Pod不可以被kill掉

- job
给job设置优先级

## 测试案例
### 简单测试
1. 运行job
2. targetNode上优先级最低的Pod被立刻执行Terminating和启动一个新的Pod
3. targetNode上优先级第2低的Pod被立刻执行Terminating和启动一个新的Pod
4. 直到targetNode的资源小于thresholds或者 underNode（targetThresholds-thresholds）可分配资源为0.

### 定制化最简单的最稳定性策略
- 禁止terminating某些pod
    1. 设置优先级

- 稳定性策略
    1. 每次每个节点只kill掉一个pod
    2. 每次只操作一个负载高的节点
    3. 设置10分钟执行一次

1. 运行job
2. 获取使用资源量最多的node  mostTargetNode
3. kill 掉 mostTargetNode上优先级最低的node